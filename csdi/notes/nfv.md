# Network Function Virtualization

* [GitHub Notes](https://github.com/Emilio66/CSDI/blob/master/13_NFV_%E8%B0%AD%E9%92%A7%E5%8D%87_%E6%9D%8E%E5%AE%97%E5%9E%9A_%E9%99%88%E6%96%87%E5%BA%B7.md)
* [基于Click系统的软件路由器的设计与实现](https://wenku.baidu.com/view/3aa3d44ef7ec4afe04a1df6f.html)

## Overview

![](img/12-1.png)

其中，中间那部分的网络功能开销高昂：

![](img/12-2.png)

NFV，Network Function Virtualization Network Functions(Middleboxes)，网络功能虚拟化，就是去虚拟化Firewall，IDS和DNS这些网络功能，也就是通过软件模拟实现这些网络功能。 或者说是：运行在云设施的网络服务。

 NFV目标：

* 省钱：
  * 使用更便宜的商业服务器来实现网络功能；
  * 减少专有硬件的使用，从而降低能耗，并且能够方便地维护。
* 赚钱：
  * 加速网络服务部署； 
  * 网络基础设施作为服务。

有另一个术语，SDN，Software-defined networki，它侧重于控制层的革新/虚拟化，而NFV更侧重于数据层面的虚拟化。它们的关系如下图所示：

![](img/12-3.png)

软件路由器的最大优势就是价格低廉，比如需要支持100Mbps的网络转发量——该转发量相当于一个具有100台主机规模的公司当前的网络需求，采用低端硬件路由器需要几万元投资，而采用软件路由结构只需要一台低端PC连接一个集线器和若干hub，投资不超过1万元，软件则是完全免费的。另外，软件路由器的扩展性好、灵活性强，用户能够方便的根据个人需求修改路由器功能，也可以方便的更新路由器版本而不必更换硬件。软件路由器主机还能担当其它网络服务如Web和ftp服务等，一机多用能大大增加投资收益。

## Click Architecture

Click是一个能够灵活配置的软件路由结构。它是由一系列包处理模块(被称为组件)按照特定方式组合而成。组件是click中最小的功能单元，它只实现最简单最单一的功能如排队、调度、分类、复制等，稍微复杂的功能可以用若干个组件复合而成。一个路由配置是一个有向图，组件位于顶点，数据包沿着有向图的边传输，如图1所示。Click的一些特性如下拉连接、基于设备的上下文，能增强组的功能，使配置更容易更利于编写。一个click组件代表着一个最基本的功能单元，例如减少一个IP包的生存时间域，而不是实现一个复杂的功能如IP路由。用户通过选择组件并连接它们来实现不同的路由功能。在一个运行的路由器中，每一个组件是一个属性为私有的C++对象，连接用一个指向组件对象的指针代替，通过一个简单的虚拟函数实现一个数据包沿着一个方向连接。

![](img/12-4.png)

Click系统用C++语言已经封装了很多的组件，每一个组件都实现一个简单的功能。我们要做的工作就是通过click配置语言对这些组件进行连接，从而完成特定的路由功能，因此，click语言对于实现路由功能是特别方便的。Click配置语言由两个部分构成:声明组件和连接。它的语法非常简单易懂，例如图1的配置可以写成如下形式: 

```
FromDevice(eth0) -> Counter() -> Discard();
```

建立一个文本将保存上述内容，如保存为/home/click-2.0/test.click，这样就生成了一个自 已的配置文件。切换到click程序目录下，运行click /home/click-2.0/test.click就可以把该配置运行起来。

一般而言Click路由器包含以下凡个组成部分：

* 组件(Element)。组件是路由体系结构中最基本的部分，每个组件完成一个最基本的功能，路由能实际就是有限个组件的组合，组件有四个重要的组成部分：

  * 组件类：click中组件类是用C++编写的，每个组件都属于一个组件类，通过组件类即可声明组件对象。从组件类声明对象即可得到实现特定功能的组件，可通过类代码决定该类组件对象的接口、组件初始化、以及数据处理流程等；
  * 端口：click组件在设计时便考虑到对外的接口，一个组件有多少输入端口与多少输出端口往往取决于该组件实现的具体功能，如一个counter组件，它的作用是测量包数和速率，那么它只需要一个输入端口用于输入数据包，一个输出端口将数据包无改变地输出即可。除此之外，在click中一些特定端口有相同的语义，例如，第二输出端口经常用于发送错误的数据包；
  * 配置串：配置串是用逗号进行分隔的参数列表，它包含了一些用于组件初始化的附加参数，用户可以显示提供或使用默认串作为参数；
  * 方法接口:每一个组件都支持一个或多个方法接口，它类似于C++类中的公有函数，因此也可称为函数接口，通过调用它可实现特定功能，它是类对象的功能函数。每一个组件都支持简单的数据包传输接口，但组件可以创建任意数量的函数接口，例如，一个队列能通过创建接口函数来报告它的长度。组件通过这样功能性函数接口来进行数据通信。

  下图显示了一个简单的click组件Tee(2), "Tee"是组件类的名称，配置串“2"表示有两个输出端口。该类组件的功能是将输入端口接收的数据包发送到它的输出端口。

  ![](img/12-5.png)

* 数据包结构。这是在click内部定义的一种数据结构，用于存储经过处理的特定格式的数据包。一般情况下，路由器对数据包处理时所需信息只在前三层，即最多解析到IP头部，便可以获得所需信息，如果进行处理时是针对整个数据包，则毫无疑问会降低处理效率。无论怎么样，路由器都不会去对数据部分进行处理，更不会对数据部分进行修改，为了提高click组件内部的处理效率，click内部定义了一种被称为注释结构的数据结构。Click路由器在接收到数据包后，会提取数据包包头。放入到注释结构中，值得注意的是，注释结构除了包含数据包包头，还包含一个指向数据内容的指针，这样注释结构才能完整的表达出整个数据包。这样以后对数据包的处理变为对注释结构的处理，使路由器处理效率大大增强。

* 连接方式。Click支持上拉、下推、不定方式这三种连接方式。在一个下推连接中，数据包的发起者为源组件，它从一个源组件发送到一个目的组件，目的组件只是被动的负责接收，这跟数据包通过大多数软件路由器是一样的。相反，在上拉链中，数据包的传送发起者为目的组件，它要求源组件发送一个数据包，或者当没有数据包时发送一个空指针。每一种形式的数据包传输通过一个虚函数进行实现。不定方式是该组件在初始化时并不确定为下推型或是上拉型，它根据所直接连接的组件决定，如果它与上拉组件直接连接，则表现为上拉方式，否则表现为下推方式。必须说明的是，不定方式并不意味着能随意更改连接方式，它的连接类型一经确定，就不会再更改。上推与下拉两种方式不能直接连接，原因是它们的主动性相反，不能判断出数据包的发起者，容易出现逻辑上的错误，不利于系统的扩展。

* 数据包存储。Click系统中有单独的组件类，有相应的组件能对队列直接进行操作，因此不会在输入输出端口上出现内置队列，也省去了相对复杂的开销;队列在click中是明确的对象，它是通过一个独立的对队组件进行实现的。这就使得设计者能够对路由器数据包的存储有一个很明确的控制。一个队列有一个下推输入端口和上拉输出端口，输入端口通过入队操作将数据包推进，输出端口通过出队操作对上拉操作进行响应并返回它们。

  ![](img/12-6.png)

* CPU调度。组件是CPU调度的基本单元，同样是数据包处理的基本单元。Click通过一个任务队列对CPU资源进行调度，一个组件在同一时间通过循环方式从任务队列中获取一个任务。然而，大多数组件从不被放到任务队列中，当它们的下推或上拉方法被调用时它们才被调度。如果组件如果经常初始化下推或上拉请求而得不到应答，那么它应该被放入到消息队列中。Click当前运行在一个单线程上，任何数据包传输函数必须在下一个任务开始前返回到调用它的函数那里。路由器继续处理每一个下推数据包，直到它被存储或者丢弃，因此，在一个配置图中队列的位置决定了它以何种方式进行CPU调度。

* 基于流的上下文关系。如果组件A想调用组件B的函数接口，它首先必须能够定位，基于流的上下文关系能够通过数据包的连接方式获取传递关系，进而对所需组件进行定位，例如它可以定位从一个给定组件开始的数据包将要在哪个地方结束，或者在一个给定组件结束的数据包从哪里开始。基于流的上下文关系通过一种数据流算法进行计算，在初始化阶段，组件对它调用一次，存储结果以进行快速查询，任何组件使用基于流的上下文关系时都必须处理若干个结果组件，如果结果组件数量异常则报错，通过这种方式Click能对系统结构进行错误检查，避免出现冲突现象。

* 组件实现。在Click中组件是采用C++语言实现，每个组件类都派生于基础类Element，它有约20个虚函数并提供了默认实现，用户开发自已的组件类时，根据实际需要对其中的某些虚函数进行重载即可，因此，组件的实现非常容易。

* 设备轮循方式。Click对设备的调用是采用轮循方式，这是由于路由器工作时处理的数据量很大，采用轮循方式可以有效地减少对系统CPU的访问，因而大大提高路由器的综合性能

* 丢包策略：Click通过队列元素来实现一个简单的Dropping策略， 也就是当包数目超过配置的最大长度时，这些包都会被扔掉。同时click支持将其他元素与队列元素组合，构成更复杂的丢包策略:

  * RED：Random Early Detection。 该Element以下游的最近的队列长度作为Dropping的依据;
  * RED over multiple queues: 如果RED的下游有多个队列，那就将这些队列的长度都加起来作为Dropping的依据；
  * weight RED: 每个包根据它的优先级有不同的Drop的概率。

* 调度策略：通过pull处理，一个调度器可以在一个click元素中实现，并且只维护本地的路由配置。Click实现了RoundRobinSched 和 PrioSched这两个元素，并且可以通过元素之间的组合实现更加复杂的调度策略。


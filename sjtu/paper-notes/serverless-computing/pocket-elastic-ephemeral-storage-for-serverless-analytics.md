# Pocket: Elastic Ephemeral Storage for Serverless Analytics

* [Pocket: Elastic Ephemeral Storage for Serverless Analytics](https://web.stanford.edu/~anakli/pdf/pocket.pdf)

刚开始看这篇文章的时候，感觉这篇文章前面部分写的和[Understanding Ephemeral Storage for Serverless Analytics](https://www.usenix.org/system/files/conference/atc18/atc18-klimovic-serverless.pdf)也太像了吧，随手看了一下作者，噢，原来完完全全就是同一帮人写的。想起这周组会的时候任老板说我们组现在就缺一篇重量级论文的发表完成自证，一旦发表出去，后面的很多工作其实好做很多，都可以根据这篇论文去发散。

关于短暂数据存储这一块的相关介绍可以看[understanding-ephemeral-storage-for-serverless-analytics](understanding-ephemeral-storage-for-serverless-analytics.md)。在这篇文章中，<u>论文团队指出了一些当前短暂存储服务的一些缺点</u>，比如：

* 分布式键值存储在各种测试结果表现了良好的性能，但是用户必须负责管理存储群集规模和配置，其中包括选择要配置的适当计算，存储和网络资源。此外，更改实例类型或添加/删除节点可能需要拆除和重新启动群集，节点需要几分钟才能启动，而服务将按小时计费。

* 不同存储技术（例如，DRAM，NVM，闪存和HDD）的可用性增加了为性能和成本找到最佳集群配置的复杂性。 但是，存储技术的选择至关重要，因为作业可能会表现出不同的存储延迟，带宽和容量要求，而不同的存储技术在性能特征和成本方面差别很大。每种资源配置都会导致不同的性能和成本，为作业寻找帕累托有效的存储分配非常重要，并且在多个作业中变得更加复杂。

<u>那么，一个合格短暂存储应该有哪些特点？</u>

* **针对各种对象大小的高性能**：serverless 分析应用程序在存储，分发和处理数据方面存在很大差异。这种多样性反映在作业期间生成的短暂数据的粒度中。读/写大对象的应用程序需要高吞吐量（例如，使用500 lambdas排序100 GB需要高达7.5 GB / s的临时存储吞吐量），而低延迟对于小对象访问很重要。*因此，短暂的数据存储必须为整个对象大小范围提供高带宽，低延迟和高IOPS*。

* **自动和细粒度扩展**：serverless 计算的关键承诺之一是动态满足应用程序需求的灵活性。serverless 框架可以即时启动数千个短期任务。因此，用于serverless 应用程序的短暂数据存储可以在几分之一秒内观察到I/O请求的风暴。一旦负载消散，存储资源应按比例缩小以提高成本效率。此外，serverless平台的用户需要一种存储服务，该服务自动管理资源并仅为其作业实际消耗的细粒度资源向用户收费，以便匹配serverless 计算已经为计算和内存资源提供的抽象。自动资源管理很重要，因为让用户去配置群集的性能与成本权衡是一种负担找到帕累托最优点是不容易的；在使用任何低成本资源分配导致次优执行时间的同时，添加资源仅增加成本而不增加执行时间是一个重点。*总之，临时数据存储必须自动调整资源分配的规模，以满足应用程序I / O要求，同时最大限度地降低成本*。

* **存储技术意识**：除了对群集资源进行权限化之外，存储系统还需要决定使用哪种存储技术来处理哪些数据。 云中可用的各种存储介质允许不同的性能成本权衡。作业的最佳存储介质选择取决于其特性。 *因此，临时数据存储必须将应用程序数据放在正确的存储技术层上，以提高性能和成本效率*

* **容错**：短暂数据仅在作业执行期间有价值，并且可以轻松地重新生成。*因此，短暂的存储解决方案不必像传统存储系统那样提供高容错性*。

论文于是引出了Pocket，一种用于临时数据的弹性分布式存储服务，可自动动态地对存储群集资源分配进行权限化，从而在降低成本的同时提供高I / O性能。 <u>Pocket的关键设计原则：</u>

* 职责分离：Pocket在三个不同的平面上划分责任：控制平面，元数据平面和数据平面。 控制平面管理群集大小调整和数据放置。 元数据平面跟踪存储在数据平面中的节点上的数据。 这三个平面可以根据负载的变化独立调整。
* 亚秒级响应时间：所有I / O操作都是简单的，目标是亚毫秒级别。 Pocket的存储服务器针对快速I / O进行了优化，仅负责存储数据（而非元数据），使其易于扩展或缩小。 控制器以第二粒度缩放资源，并通过智能地控制传入的作业数据来平衡负载。 这使Pocket具有弹性。
* 多层存储：Pocket利用不同的存储介质（DRAM，闪存，磁盘）将作业数据存储在满足应用程序I / O需求的层中，同时最大限度地降低成本。

下图展示了<u>Pocket的系统架构</u>：

![1](img/1.jpg)

该系统由逻辑集中控制器，一个或多个元数据服务器和多个数据平面存储服务器组成存储服务器上的彩色条显示集群中所有作业的已使用和已分配资源。

控制器为作业分配存储资源，并随着作业数量及其要求随时间变化而上下动态扩展Pocket元数据和存储节点。 控制器还为作业（即，用于作业数据的节点和存储介质）做出数据放置决定。

元数据服务器通过将客户端请求引导到适当的存储服务器来实施由控制器生成的粗粒度数据放置策略。 Pocket的元数据平面以块的粒度管理数据，块的大小是可配置的。 在部署中使用64 KB的块大小。 大于块大小的对象被分成块并分布在存储服务器上，使Pocket能够支持任意对象大小。 客户端访问配备有不同存储介质（DRAM，闪存和/或HDD）的性能优化的存储服务器上的数据块。

<u>Pocket为应用程序提供了一些接口。</u> Pocket公开了一个对象存储API，其中包含为短暂存储用例量身定制的一些函数。 描述了这些函数以及它们如何映射到Pocket的控制平面，元数据平面和数据平面。

* **控制函数**：应用程序使用两个API调用，`register_job`和`deregister_job`，与Pocket控制器进行交互。 `register_job`接受关于作业特征（例如，并行度，等待时间敏感度）和要求（例如，容量，吞吐量）的提示。 这些可选提示可帮助控制器对资源分配进行权限分配，以优化性能和成本（参见§4.1）。 `register_job`返回作业标识符和分配用于管理作业数据的元数据服务器。 `deregister_job`通知控制器serverless作业已完成。

* **元数据函数**：虽然每个作业发出一次控制API调用，但作业中的serverless任务可以在其生命周期内多次与Pocket元数据服务器交互，以写入和读取临时数据。 serverless客户端使用`connect`调用与Pocket的元数据服务建立连接。 Pocket中的数据存储在以存储桶组织的对象中。 使用名称（字符串）标识对象和存储桶。 客户端可以通过传递其作业标识符和存储桶名称来创建和删除存储桶并枚举存储桶中的对象。 客户端还可以查找和删除现有对象。 这些元数据操作类似于其他对象存储（如Amazon S3）支持的操作。

* **存储函数**：客户端以字节粒度向对象`put`数据或从对象`get`数据。 客户端为所有操作提供其作业标识符。  `put`和`get`操作首先涉及元数据查找。 Pocket通过一个可选的数据生存期管理提示来增强基本的 `put`和`get`对象存储API调用。 由于临时数据通常仅在作业执行期间有价值，因此Pockets默认的粗粒度行为是在作业取消注册时删除作业的数据。 但是，应用程序可以设置标志以覆盖特定对象的默认删除策略。如果客户端发出PERSIST标志设置为true的`put`，则该对象将在作业完成后保留。 该对象存储在长时间运行的Pocket存储节点上，并将保留在Pocket中，直到它被明确删除或者超时结束。  如果客户端在DELETE标志设置为true的情况下发出`get`，则该对象将在读取后立即删除，从而实现更高效的垃圾回收。短暂数据通常只写入和读取一次。 例如，mapper将写入指定给特定reducer的中间对象。 这些数据可以在使用后立即删除，而不是等待作业完成和取消注册

重新回到这个图：

![1](img/1.jpg)

<u>使用Pocket了解serverless分析应用程序的生命周期</u>：

* 步骤i：在启动lambdas之前，应用程序首先向控制器注册，并可选择提供有关作业特征的提示； 
* 步骤ii：控制器确定要使用的存储层（DRAM，闪存，磁盘）和分配作业数据的存储服务器数量，以满足其吞吐量和容量要求。 控制器生成关于存储服务器的权重映射，以指定作业的数据放置策略，并将此信息发送到它分配用于管理作业的元数据和引导客户端I / O请求的元数据服务器。 如果控制器需要启动新的存储服务器以满足作业的资源分配，则作业注册调用将停止，直到这些节点可用；
* 注册完成后，该作业将启动lambdas。 Lambda首先连接到其分配的元数据服务器，其IP地址由作业注册时的控制器提供。 Lambda客户端通过首先联系元数据服务器来获取要写入数据的存储服务器的IP地址和块地址来写入数据。 对于跨越多个块的大对象的写入，客户端以流方式从元数据服务器请求容量分配; 当单个块的容量耗尽时，客户端向元数据服务器发出新的容量分配请求。 Pocket的客户端库在内部重叠下一个块的元数据RPC，同时为当前块写入数据以避免停顿。 类似地，lambda通过首先以类似的方式联系元数据服务器来读取数据。 客户端缓存元数据以防需要多次读取对象；
* 步骤iii：当作业中的最后一个lambda完成时，该作业将取消注册该作业以释放Pocket资源。 同时，随着作业的执行，控制器会不间断地监视存储和元数据服务器（存储服务器上的水平条）中的资源利用率，以根据需要添加/删除服务器，从而在提供高性能的同时最大限度地降低成本。

<u>关于容错的处理。</u> 前面讲了论文认为“短暂的存储解决方案不必像传统存储系统那样提供高容错性”，Pocket使用了以下方式来处理节点故障：

* 存储服务器将心跳发送到控制器和元数据服务器。当存储服务器无法发送心跳时，元数据服务器会自动将其块标记为无效。因此，客户端对存储在故障存储服务器上的数据的读取操作将返回“数据不可用”错误。 Pocket目前期望应用程序框架重新启动serverless任务以重新生成丢失的临时数据。一种常见的方法是应用程序框架跟踪数据沿袭，这是生成每个对象的任务序列[78,39]。
* 对于元数据容错，Pocket支持在共享存储上记录所有元数据RPC（远程过程调用）操作。当元数据服务器发生故障时，可以通过重播共享日志来重建其状态。
* 控制器容错可以通过主从复制来实现。

一个关于Pocket的重要内容就是Pocket如何<u>适当调整资源分配的规模</u>？

当作业注册时，Pocket的控制器利用通过API传递的可选提示来保守估计作业的延迟，吞吐量和容量要求，并找到经济高效的资源分配。 除了预先为作业分配资源外，Pocket还会持续监控集群的整体利用率，并根据负载决定何时以及如何扩展存储和元数据节点。以下具体展开： §4.2描述了Pocket的资源扩展机制及其数据导向策略以平衡负载。

首先是<u>找到经济高效的资源分配</u>，当作业注册时，控制器首先确定三个维度的资源分配：吞吐量，容量和存储介质的选择。 然后，控制器使用在线bin-packing算法将资源分配转换为节点上的资源分配Pocket使用适用于通过注册作业API传递的可选提示的启发式方法。 下图列出了Pocket支持的提示及其对为作业分配的存储介质的吞吐量，容量和选择的影响，以及论文在AWS上部署的示例（括号中）：

![2](img/2.jpg)

* 如果没有关于作业的提示，Pocket使用默认的资源分配，保守地过度配置资源以高成本实现高性能。 默认情况下，Pocket保守地假设作业对延迟敏感。 因此，Pocket会在溢出到其他存储层之前填充作业的DRAM资源，以便保证存储延迟。 如果作业暗示它对延迟不敏感，则控制器不会为作业分配DRAM，而是使用最具成本效益的存储技术来控制控制器估算作业需求的吞吐量和容量。

* 知道作业的最大并发lambda数N，允许Pocket计算对作业吞吐量要求的不太保守的估计。 如果提供此提示，则Pocket分配的吞吐量等于每个λ的峰值网络带宽限制的N倍（例如，AWS上每个lambda约600 Mb / s）。 N可以受作业的固有并行性或云提供者的任务调用限制（例如，AWS上的1000默认值）限制。

* Pocket的API还接受有关作业的总吞吐量和容量要求的提示，此信息可以来自分析。 当Pocket仅收到吞吐量提示时，控制器会分配与作业吞吐量分配成比例的容量。 该比例由所使用的VM上的存储吞吐量与容量比设置。 反之亦然，如果仅提供容量提示，Pocket将根据VM容量与吞吐量的比率分配吞吐量。 

**重要的是提示可由应用程序开发人员指定或由应用程序框架提供。** 例如，论文用于运行lambda分布式软件编译的框架会自动推断并合成作业的依赖图。 因此，该框架可以为Pocket提供有关作业最大并行度的提示。

然后是<u>Pocket的资源扩展机制及其数据导向策略以平衡负载</u>。Pocket可以动态扩展群集资源，以适应多个作业随时间的弹性应用程序负载。 Pocket集群的核心是一些用于运行控制器的长期运行节点，最少数量的元数据服务器（在部署中只有一个），以及最小数量的存储服务器（在部署中有两个）。 特别的，具有较长生命周期的PERSIST标志写入的数据始终存储在群集中长时间运行的存储服务器上。 除了这些持久性资源之外，Pocket还会根据负载按需扩展资源。 首先描述水平和垂直缩放的机制，控制器通过处理包含其CPU，网络和存储介质容量使用情况的存储和元数据服务器的心跳来监控群集资源利用率。节点每秒向控制器发送统计信息。

* 启动新存储服务器时，控制器会提供存储服务器必须与之建立连接的所有元数据服务器的IP地址以加入群集。 新存储服务器将其一部分容量注册到这些元数据服务器中的每一个。 元数据服务器独立管理其分配的容量，并且不会相互通信。 存储服务器会定期向元数据服务器发送心跳

* 要删除存储服务器，控制器会通过在传入作业的权重映射中为其分配零权重来将存储服务器列入黑名单。 这可确保元数据服务器不会将数据从新作业引导到此节点。 控制器指示随机选择的元数据服务器在列入黑名单的存储服务器的心跳响应中设置“终止”标志。 列入黑名单的存储服务器等待其容量完全释放，因为作业终止并且他们的短暂数据被垃圾收集。 然后，存储服务器终止并释放其资源。

* 当控制器启动新的元数据服务器时，元数据服务器等待新的存储服务器启动并注册其容量。 要删除元数据服务器，控制器会向节点发送“kill”RPC。 元数据服务器等待其管理的所有容量被释放，然后通知所有连接的存储服务器以关闭其连接。 当所有连接关闭时，元数据服务器终止。 然后，存储服务器在新元数据服务器上注册由旧元数据服务器管理的容量。

* 除水平缩放外，控制器还管理垂直缩放。 当控制器观察到CPU利用率很高并且节点上有其他核可用时，控制器通过心跳响应指示节点使用额外的CPU核心。

然后讨论Pocket用于通过仔细控制跨服务器的请求来平衡群集负载的策略。前面说了，控制器会为存储服务器生成一个权重映射。Pocket通过为作业生成权重映射，将作业的资源分配转换为特定存储服务器上的资源分配。 权重映射是一个关联数组，将每个存储服务器（由其IP地址和端口标识）映射到0到1的权重，该权重表示要放置在该存储服务器上的作业数据集的分数。 如果在作业的权重映射中为存储服务器分配权重1，它将存储所有作业的数据。 控制器将权重映射发送到元数据服务器，元数据服务器通过使用基于作业权重映射中的权重的加权随机选择将客户端请求路由到存储服务器来实施数据放置策略。

权重映射取决于作业的资源要求和可用的群集资源。 Pocket使用在线bin-packing算法，该算法首先尝试在活动存储服务器上调整作业的吞吐量，容量和存储介质分配，并且只有在通过与其他作业共享资源无法满足作业要求时才启动新服务器。 如果作业需要的资源多于当前可用的资源，则控制器会在应用程序等待其作业注册命令返回时启动必要的存储节点。

* **群集大小调整策略**：Pocket使用策略弹性扩展群集，该策略旨在维护目标范围内每种资源类型（CPU，网络带宽和每个存储层的容量）的总体利用率。可以为每种资源类型单独配置目标利用率范围，并为元数据服务器，长期运行的存储服务器（存储使用PERSIST标志集写入的数据）和常规存储服务器单独管理。对于论文的部署，对于元数据和存储节点，对所有资源维度使用较低的利用率阈值60％和较高的利用率阈值80％。范围是根据经验调整的，取决于添加/删除节点所需的时间。如果整体CPU，网络带宽和容量利用率低于目标范围的下限，则Pocket的控制器会通过删除存储服务器来缩减群集。在这种情况下，Pocket将删除属于该层容量利用率最低的存储服务器。如果整体CPU，网络带宽或容量利用率高于目标范围的上限，Pocket会添加存储服务器。为了响应CPU负载峰值或间歇，Pocket首先尝试在水平扩展节点数量之前垂直扩展元数据和存储服务器上的CPU资源。

* **通过数据控制平衡负载**： 由于短暂的数据对象只能存活数十到数百秒，因此在添加或删除节点时迁移此数据以重新分配负载会产生很高的开销。 相反，Pocket专注于在加入集群的处于活跃状态下的新存储服务器上的传入作业的数据转向。 Pocket通过为每个作业的权重映射中的存储服务器分配特定权重来控制数据转向。 为了平衡负载，控制器为未充分利用的存储服务器分配更高的权重。

关于实现和评估这部分，直接看论文相关部分。

总的来说，本文分析了与高效数据共享相关的挑战，介绍了Pocket，一个用于serverless分析的短暂数据存储。 Pocket为分析工作负载提供高度灵活，经济高效且精细的存储解决方案。 Pocket使用严格的控制，元数据和数据管理职责分离来实现这些目标。论文对AWS的评估表明，Pocket可为任意大小的数据集提供高性能数据访问，并结合多个存储层的自动细粒度扩展，自我管理和经济高效的数据放置。



[返回目录](../README.md)

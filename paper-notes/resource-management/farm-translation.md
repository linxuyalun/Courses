# No compromises: distributed transactions with consistency, availability, and performance

* [No compromises: distributed transactions with consistency, availability, and performance](https://pdos.csail.mit.edu/6.824/papers/farm-2015.pdf)

## Abstract

具有强一致性和高可用性的事务简化了分布式系统的构建和推理。但是，以前的实现性能表现不佳。这迫使系统设计者完全避免事务，削弱一致性保证，或者提供需要程序员对其数据进行分区的单机器事务。本文表明，现代数据中心不需要折衷。研究表明，主内存分布式计算平台farm能够提供具有严格的**可序列化性、高性能、持久性和高可用性的**分布式事务。Farm在具有4.9 TB数据库的90台机器上每秒实现1.4亿个TATP事务的峰值吞吐量，并在不到50毫秒的时间内从故障中恢复。实现这些结果的关键是根据第一原则设计新的事务、复制和恢复协议，以利用RDMA和新的、不成熟的商品网络。提供非易失性DRAM的方法。

## 1. Introduction

具有高可用性和严格序列化的事务通过提供一个简单、强大的抽象来简化分布式系统的编程和推理：一台机器永远不会失败，并且一次执行一个事务的顺序与实时一致。然而，以前在分布式系统中实现这种抽象的尝试导致了较差的性能。因此，Dynamo[13]或Memcached[1]等系统通过不支持事务或实现弱一致性保证来提高性能。另一些则只在所有数据都驻留在一台机器上时才提供事务，这迫使程序员对数据进行分区，并使正确性的推理变得复杂。

本文论证了现代数据中心的新软件可以消除妥协的必要性。它描述了主内存分布式计算平台Farm[16]中的事务、复制和恢复协议。FaRM提供具有严格序列化、高可用性、高吞吐量和低延迟的分布式ACID事务。这些协议是根据第一原则设计的，以利用数据中心出现的两种硬件趋势：具有RDMA的快速商品网络和提供非易失性DRAM的廉价方法。非易失性是通过将电池连接到电源单元，并在电源故障时将DRAM的内容写入SSD来实现的。这些趋势消除了存储和网络瓶颈，但也暴露了限制性能优势的CPU瓶颈。Farm的协议遵循三个原则来解决这些CPU瓶颈：减少消息计数，使用单边RDMA读写而不是消息，以及有效地利用并行性。

FaRM通过在数据中心的机器上分布对象来扩展，同时允许事务跨越任意数量的机器。与使用paxos（如[11]中所示）复制协调器和数据分区不同，Farm通过将垂直paxos[25]与主备份复制以及与主备份和备份直接通信的未复制协调器一起使用来减少消息计数。farm使用乐观并发控制和四阶段提交协议（lock、validation、commit backup和commit primary）[16]但是我们通过消除锁阶段中备份的消息改进了原始协议。

FaRM通过使用单边RDMA操作进一步降低了CPU开销。单侧RDMA不使用远程CPU，它避免了大部分本地CPU开销。FaRM事务在事务执行和验证期间使用单边RDMA读取。因此，它们在远程只读参与者上不使用CPU。此外，协调器在将记录记录到事务中修改的对象副本的非易失性预写日志时使用单侧RDMA。例如，协调器使用单侧RDMA将提交记录写入远程备份。因此，事务在备份时不使用前台CPU。当延迟截断日志以就地更新对象时，将在后台使用CPU。

使用单面RDMA需要新的故障恢复协议。例如，FaRM到期时不能依赖服务器拒绝传入的请求，因为请求由不支持租约的NIC提供服务。我们通过使用精确的成员身份[10]来解决这个问题，以确保机器同意当前的配置成员身份，并且只向作为成员的机器发送单边操作。FaRM也不能依赖传统的机制来确保参与者在准备阶段拥有提交事务所需的资源，因为事务记录是在不涉及远程CPU的情况下写入参与者日志的。相反，FaRM使用保留来确保日志中有足够的空间用于提交所需的所有记录，并在启动提交之前截断事务。

Farm中的故障恢复协议很快，因为它有效地利用了并行性。它将每一位状态的恢复均匀地分布在集群中，并将恢复并行地分布在每台机器的核心上。此外，它使用两个优化来允许事务执行与恢复并行进行。首先，在锁恢复阶段完成后，事务开始访问受失败影响的数据，该阶段只需几十毫秒，而不是等待几秒钟等待恢复的剩余时间。第二，不受故障影响的事务继续执行而不阻塞。Farm还通过利用快速网络交换频繁的心跳来提供快速的故障检测，并使用优先级和预分配来避免误报。

我们的实验结果表明，您可以拥有一切：一致性，高可用性和性能。 FaRM在不到50毫秒的时间内重新覆盖单机故障，并且仅用几台机器就能胜过最先进的单机内存交易系统。 例如，当它仅在三台机器上运行时，它比Hekaton [14,26]实现了更好的吞吐量，并且它比Silo具有更好的吞吐量和延迟

## 2. Hardware trends

Farm的设计是受数据中心机器中丰富、廉价的DRAM可用性的推动。一个典型的数据中心配置为每台2插槽机器有128-512GB的DRAM[29]，DRAM的成本低于12美元/GB。这意味着一个千兆字节的DRAM只需要2000台机器，这足以容纳许多有趣的应用程序的数据集。此外，Farm利用两种硬件趋势来消除存储和网络瓶颈：非易失性DRAM和快速的RDMA商品网络。

### 2.1 Non-volatile DRAM 

“分布式不间断电源（UPS）”利用锂离子电池的广泛可用性，与使用铅酸电池的传统集中式方法相比，降低了数据中心UPS的成本。 例如，微软的Open CloudServer（OCS）规范包括本地能量存储（LES）[30,36]，它将锂离子电池与机架内每个24机器机箱中的电源单元集成在一起。 估计的LES UPS费用低于每焦耳0.005美元。 这种方法比传统UPS更可靠：锂离子电池过度配置多个独立电池，任何电池故障只影响机架的一部分。

分布式UPS有效地使DRAM耐用。当发生电源故障时，分布式UPS利用电池的能量将内存内容保存到商品SSD。这不仅通过避免同步写入到SSD提高了常见情况下的性能，而且还通过仅在发生故障时写入到SSD来保留SSD的生命周期。另一种方法是使用非易失性DIMM（NVDIMM），它包含自己的私有闪存、控制器和超级电容器。不幸的是，这些设备是专门化的、昂贵的和笨重的。相反，分布式UPS使用商品DIMM并利用商品SSD。唯一的额外成本是SSD和UPS电池本身的预留容量。

电池供应成本取决于将内存保存到SSD所需的能量。我们在一台标准的2插座机器上测量了一个未经优化的原型。如果出现故障，它将关闭HDD和NIC，并将内存中的数据保存到单个M.2（PCIe）SSD，并且每保存一GB数据消耗110焦耳。在保存期间，大约90焦耳用于为机器上的两个CPU插座供电。额外的固态硬盘减少了节省数据的时间，因此也减少了能耗（图1）。优化，如将CPU置于低功耗状态，将进一步降低能耗。

在最坏情况下，配置（单SSD，无优化）为每焦耳0.005美元，非易失性的能源成本为0.55美元/GB，保留SSD容量的存储成本为0.90美元/GB。总的额外成本低于基础DRAM成本的15%，这是相对于成本为DRAM 3–5倍的NVDIMM的显著改进。因此，将所有的机器内存都当作非易失性RAM（NVRAM）来处理是可行的，而且是经济有效的。服务器场将所有数据存储在内存中，并认为将数据写入多个副本上的NVRAM时，它是持久的。

### 2.2 RDMA networking

FaRM在可能的情况下使用单边RDMA操作，因为它们不使用远程CPU。我们根据之前的工作和额外的测量结果做出这一决定。在[16]中，我们展示了在一个20台机器的roce[22]集群上，当所有机器从集群中的其他机器上随机读取所选的小对象时，RDMA的读取性能比可靠的rpc要好2倍。瓶颈是NIC消息速率，我们的RPC实现需要的消息是单侧读取的两倍。我们在一个90机器集群上复制了这个实验，其中每台机器都有两个InfinibandFDR（56 Gbps）网卡。与[16]相比，这将使每台机器的消息速率增加一倍以上，并消除了NIC消息速率瓶颈。RDMA和RPC现在都是CPU绑定的，性能差距增加到4倍，如图2所示。这说明了减少CPU开销以实现新硬件的潜力的重要性。

## 3. Programming model and architecture

FaRM为应用程序提供了跨集群中机器的全局地址空间的抽象。每台机器运行应用程序线程并将对象存储在地址空间中。FaRM 的 API提供对事务中本地和远程对象的透明访问。应用程序线程可以随时启动事务，并成为事务的协调器。在事务执行期间，线程可以执行任意逻辑以及读取、写入、分配和释放对象。在执行结束时，线程调用FaRM来提交事务。

FaRM事务使用乐观并发控制。在执行期间本地缓冲更新，并且只有成功提交时其他事务才能看到更新。提交可能由于与并发事务或失败的冲突而失败。FaRM为所有成功提交的事务提供严格的可序列化性。在事务执行期间，farm保证单个对象读取是原子的，它们只读取提交的数据，对同一对象的连续读取返回相同的数据，对事务写入的对象的读取返回写入的最新值。它不保证不同对象的读取之间的原子性，但在这种情况下，它保证事务不会提交，确保提交的事务是严格可序列化的。这允许我们将一致性检查推迟到提交时间，而不是对每个读取的对象重新检查一致性。但是，它增加了一些编程复杂性：FaRM应用程序必须在执行期间处理这些临时的不一致。自动处理这些不一致是可能的。

farm api还提供了无锁读取（优化的单对象只读事务）和位置提示（允许程序员在同一组机器上共同定位相关对象）。应用程序可以使用这些功能来提高性能，如[16]所述。

图3显示了具有四台机器的FaRM实例。 该图还显示了机器A的内部组件。每台机器在用户进程中运行FaRM，内核线程固定到每个硬件线程。 每个内核线程运行一个事件循环，执行应用程序代码并轮询RDMA完成队列

随着时间的推移，随着机器故障或添加新机器，FaRM实例将经历一系列配置。配置是一个tuple <i;S;F;CM>，其中i是一个唯一的、单调递增的64位配置标识符，S是配置中的一组机器，F是从机器到故障域的映射，这些域预期会独立发生故障（例如，不同的机架），而CM ∈ S是配置管理器。Farm使用ZooKeeper协调服务确保机器同意当前配置，并将其存储，如垂直paxos[25]。但它并不像通常那样依靠Zookeeper来管理租约、检测故障或协调恢复。CM使用一个有效的实现来完成这些工作，该实现利用RDMA快速恢复。配置更改后，CM将调用ZooKeeper一次以更新配置。

FaRM中的全局地址空间由2个GB区域组成，每个区域都在一个主备份和F备份上复制，其中F是所需的容错性。每台机器在非易失性DRAM中存储多个区域，其他使用RDMA的机器可以读取这些区域。对象总是从包含区域的主副本中读取，如果区域在本地计算机上，则使用本地内存访问，如果是远程，则使用单面RDMA读取。每个对象都有一个64位版本，用于并发控制和复制。区域标识符到其主要和备份的映射由CM维护，并与区域一起复制。这些映射是根据其他机器的需要获取的，并由线程缓存，以及向主服务器发出单边RDMA读取所需的RDMA引用。

机器联系CM以分配新区域。CM从单调递增的计数器中分配一个区域标识符，并为该区域选择副本。复制副本选择平衡存储在每台计算机上的区域数，这些区域受容量足够的约束，每个复制副本位于不同的失败域中，并且当应用程序指定位置约束时，该区域与目标区域共存。然后，它使用区域标识符向所选副本发送准备消息。如果所有副本在分配区域时都重新移植成功，那么CM将向所有副本发送提交消息。此两阶段协议确保映射有效，并在使用之前在所有区域副本上进行复制。

这种集中式方法比我们以前基于一致散列的方法更灵活地满足故障独立性和局部性约束[16]。它还使平衡机器之间的负载和接近容量的操作更容易。对于2 GB区域，我们期望在一台典型的机器上有多达250个区域，因此一个CM可以处理数千台机器的区域分配。

每台机器还存储实现FIFO队列的环形缓冲区[16]。它们要么用作事务日志，要么用作消息队列。每个发送方-接收方对都有自己的日志和消息队列，它们物理上位于接收方上。发送方使用单边RDMA写操作将记录追加到日志的尾部。这些写入被NIC确认，而不涉及接收器的CPU。接收器定期轮询日志头以处理记录。它在截断日志时延迟地更新发送方，从而允许发送方在环缓冲区中重用空间。

## 4. Distributed transactions and replication

FaRM集成了事务和复制协议以提高性能。它比传统协议使用更少的消息，并利用单边RDMA读写来提高CPU效率和低延迟。FaRM将非易失性DRAM中的主备份复制用于数据和事务日志，并使用与主备份和备份直接通信的未复制事务协调器。它使用乐观并发控制和读取验证，就像在一些软件事务性内存系统中一样。

图4显示了FaRM事务的时间线，表1和表2列出了事务协议中使用的所有日志记录和消息类型。在执行阶段，事务操作使用单面RDMA来读取对象，并在本地缓冲写入。协调器还记录所有访问对象的地址和版本。对于与协调器位于同一台计算机上的主文件和备份，对象读取和写入日志使用本地内存访问，而不是RDMA。在执行结束时，FaRM尝试通过执行以下步骤提交事务：

1. 锁。协调器将锁定记录写入日志到任何写入对象的主计算机。它包含该主对象上所有已写入对象的版本和新值，以及具有已写入对象的所有区域的列表。主计算机通过尝试使用比较和交换将对象锁定在指定版本来处理这些记录，并返回一条消息，报告是否成功获取了所有锁。如果任何对象版本在事务读取后发生更改，或者对象当前被另一个事务锁定，则锁定可能会失败。在这种情况下，协调器中止事务。它将一个中止记录写入所有主计算机，并向应用程序返回一个错误。
2. 验证。协调器通过从其主计算机中读取所有已读但未被事务写入的对象的版本来执行读验证。如果任何对象已更改，验证将失败，事务将中止。默认情况下，验证使用单面RDMA读取。对于包含多个$t_r$对象的primary，通过RPC进行验证。阈值$t_r$（当前为4）反映了相对于RDMA读取的RPC的CPU成本。
3. 提交备份。协调器在每次备份时将提交备份记录写入非易失性日志，然后在不中断备份CPU的情况下等待来自NIC硬件的ACK。commit-backup日志记录与锁记录具有相同的负载。
4. Commit primaries。在所有提交备份写入都被确认之后，协调器将Commit primaries记录写入每个主里。它向应用程序报告在收到至少一个硬件ACK用于此类记录时的完成情况，或者如果它在本地编写了一个硬件ACK，则报告完成情况。Primaries处理这些记录的方法是：在适当的位置更新对象，增加它们的版本，然后解锁它们，这样就公开了事务提交的写操作。
5. Truncate。备份和主将记录保存在日志中，直到它们被截断（Truncate）。协调器在接收到来自所有主的ACK后，会在主处截断日志并延迟备份。它通过在其他日志记录中附加截断事务的标识符来实现这一点。备份在截断时将更新应用于对象的副本。

正确性。提交的读写事务在获取所有写锁的点上是可序列化的，在最后一次读取的点上是提交的只读事务。这是因为序列化点上所有读写对象的版本与执行期间看到的版本相同。锁定确保了写入对象的安全，验证确保了只读取对象的安全。在没有失败的情况下，这相当于在序列化点原子地执行和提交整个事务。FaRM中的序列化也很严格：序列化点总是在执行开始和向应用程序报告完成之间。

为了确保跨故障的可序列化性，必须在写入commit-primary之前等待所有备份的硬件确认。假设协调器没有收到来自某个区域R的备份B的ACK。那么，主服务器可能会公开事务修改，然后在B没有收到提交备份记录的情况下，与协调器和R的其他副本一起失败。这将导致R的更新丢失。

由于读取集只存储在协调器中，因此如果协调器失败，并且没有提交记录存活下来以证明验证成功，则事务将中止。因此，在向应用程序报告成功提交之前，协调器必须在其中一个初选中等待成功提交。这可以确保至少有一个提交记录在报告提交给应用程序的事务的任何F故障中幸存。否则，如果在写入任何提交主记录之前协调器和所有备份都失败，则此类事务仍可能中止，因为只有锁记录才能生存，并且没有验证成功的记录。

在传统的两阶段提交协议中，参与者在处理准备消息时可以预留资源来提交事务，如果没有足够的资源，则可以拒绝准备事务。但是，由于我们的协议避免在提交期间涉及备份的CPU，因此协调器必须在所有参与者处保留日志空间以保证进度。协调员为所有提交协议记录保留空间，包括在启动提交协议之前截断主日志和备份日志中的记录。日志保留是协调器的本地操作，因为协调器将记录写入它在每个参与者处拥有的日志。当相应的记录被写入时，保留被释放。如果截断被附加到另一条消息上，则也会释放截断记录保留。如果日志已满，协调器将使用保留来写入显式截断记录，以释放日志中的空间。这是罕见的，但需要确保活力。

性能。对于我们的目标硬件，这个协议比传统的分布式提交协议有几个优点。考虑使用复制的两阶段提交协议，如Spanner[11]。Spanner使用paxos[24]复制事务协调器及其参与者，这些机器存储事务读或写的数据。在传统的两阶段提交协议中，每个paxos状态机都扮演单个机器的角色[19]。这需要2F+1副本来承受F故障，并且由于每个状态机操作至少需要2F+1个往返消息，因此需要4P（2F+1）消息（其中P是事务中的参与者数）。

FaRM使用主备份复制而不是paxos状态机复制。这减少了数据复制到f+1的数量，也减少了事务期间传输的消息数量。协调器状态不被复制，并且协调器直接与主和备份通信，进一步减少了延迟和消息计数。由于复制，FaRM的开销最小：向每个远程计算机写入一个RDMA，备份任何写入的对象。协议中根本不涉及只读参与者的备份。此外，RDMA上的读验证确保了只读参与者的主要部分不需要CPU工作，并且为COMMIT-PRIMARY记录和COMMIT-BACKUP记录使用单向RDMA写入可以减少等待远程CPU的时间，还允许远程CPU工作延迟和批处理。

farm commit阶段使用$P_w(f+3)$单面RDMA写入，其中$P_w$是事务写入对象的主机器数，$P_r$单面RDMA读取其中$P_r$是从远程主要机器读取但未写入的对象数。读验证向关键路径添加了两个单边RDMA延迟，但这是一个很好的权衡：添加的延迟在没有负载的情况下仅为几微秒，并且CPU开销的减少会导致较高的吞吐量和较低的负载延迟。

## 5. Failure recovery 

FaRM通过复制提供耐久性和高可用性。我们假设机器可以通过崩溃而失败，但是可以在不丢失非易失性DRAM内容的情况下恢复。我们依靠有界时钟漂移来保证安全，并最终依靠有界消息延迟来保证活动性。

我们为所有提交的事务提供持久性，即使整个集群失败或断电：所有提交的状态都可以从存储在非易失性DRAM中的区域和日志中恢复。即使每个对象最多有f个副本丢失非易失性DRAM的内容，我们也能确保持久性。FaRM还可以在出现故障和网络分区时保持可用性，前提是存在一个分区，该分区包含大多数计算机，这些计算机彼此保持连接，并且与ZooKeeper服务中的大多数副本保持连接，并且该分区至少包含每个对象的一个副本。

FaRM中的故障恢复包括以下五个阶段：故障检测、重新配置、事务状态恢复、批量数据恢复和分配器状态恢复。

### 5.1 Failure detection

FaRM使用租约[18]检测故障。每台机器（除了CM）在CM上都有一个租约，而CM在每台机器上都有一个租约。任何租约到期都会触发故障恢复。租约是通过三次握手授予的。每台机器向CM发送一个租赁请求，并用一条消息响应，该消息既充当机器的租赁授权，又充当来自CM的租赁请求。然后，机器以租赁许可证的形式回复CM。

FaRM租赁非常短，这是高可用性的关键。在重负载情况下，FaRM可以使用5毫秒的租约来处理90个没有误报的机器集群。更大的集群可能需要两级层次结构，在最坏的情况下，这将使故障检测时间加倍。

在负荷下实现短期租赁需要谨慎实施。FaRM将专用队列对用于租用，以避免在共享队列中的租用消息延迟到其他消息类型之后。对于每台机器，使用可靠的传输需要在CM处增加一个队列对。这将导致由于NIC队列对缓存中的容量丢失而导致性能不佳[16]。相反，租用管理器使用具有无连接不可靠数据报传输的InfiniBand发送和接收谓词，这只需要为NIC上的一个额外队列对留出空间。默认情况下，每租赁到期时间的1=5尝试续订租赁，以说明潜在的消息丢失。

还必须在CPU上及时安排租约续约。FaRM使用以最高用户空间优先级（在Windows上为31）运行的专用租约管理器线程。租约管理器线程没有固定到任何硬件线程，它使用中断而不是轮询来避免饥饿的关键操作系统任务，这些任务必须定期在每个硬件线程上运行。这会将消息延迟增加几微秒，这对于租用来说并没有问题。

此外，我们不将FaRM线程分配给每台计算机上的两个硬件线程，而是将它们留给租约管理器。我们的测量结果表明，租约管理器通常在这些硬件线程上运行，而不会影响其他FaRM线程，但有时会被更高优先级的任务抢占，从而导致它在其他硬件线程上运行。因此，当使用短租约时，将租约管理器固定到硬件线程可能会导致误报。

最后，我们预先分配了租约管理器在初始化期间使用的所有内存，我们调入并固定了它使用的所有代码，以避免由于内存管理而导致的延迟。

### 5.2 Reconfiguration 

重新配置协议将FaRM实例从一个配置移动到下一个配置。使用单边RDMA操作对于获得良好的性能很重要，但它对重构协议提出了新的要求。例如，实现一致性的一种常见技术是使用租约[18]：服务器在响应访问对象的请求之前，检查是否持有对象租约。如果服务器从配置中被逐出，系统保证它存储的对象在其租约到期之前不会发生变化（例如[7]）。FaRM在为使用消息与系统通信的外部客户端的请求提供服务时使用此技术。但是，由于FaRM配置中的机器使用RDMA读取对象而不涉及远程CPU，因此服务器的CPU无法检查它是否持有租约。目前的网卡硬件不支持租用，而且不清楚将来是否会这样做。

我们通过实现精确的成员关系来解决这个问题[10]。失败后，新配置中的所有机器必须在允许对象突变之前就其成员资格达成一致。这允许FaRM在客户端而不是服务器上执行检查。配置中的机器不会向不在配置中的机器发出RDMA请求，并且会忽略对不再在配置中的机器的RDMA读操作和RDMA写操作的应答。

图5显示了一个示例重新配置timeline，包括以下步骤：

1. Suspect。当一台机器的租约在CM到期时，它怀疑该机器出现故障，并启动重新配置。此时，它开始阻塞所有外部客户机请求。如果非CM机器怀疑CM由于租约到期而出现故障，它首先要求少数“备份CMS”中的一个来启动重新配置（使用一致散列的CM的K继承者）。如果配置在超时后保持不变，那么它会尝试重新配置自身。这种设计避免了大量的同时重新配置尝试，如果CM失败。在所有情况下，启动重新配置的机器将尝试成为新的CM，作为重新配置的一部分。
2. Probe。新的CM向配置中的所有机器发出一个RDMA读取，除了可疑的机器。任何读取失败的机器也会受到怀疑。这些读取Probe允许通过一次重新配置处理影响多台机器的相关故障，例如电源和开关故障。只有当新的CM获得大多数Probe的响应时，才能进行重新配置。这样可以确保如果网络被分区，那么CM将不会位于较小的分区中。
3. Update configuration。在接收到对probe的响应后，新的CM尝试将ZooKeeper中存储的配置数据更新为<   c + 1;S;F;$CM_{id}$>，其中c是当前配置标识符，s是对probe进行响应的一组机器，F是机器到故障域的映射，$CM_{id}$是其自己的标识符。我们使用ZooKeeper znode序列号来实现原子比较和交换，这种比较和交换只有在当前配置仍然是c时才能成功。这确保只有一台机器能够成功地将系统移动到标识符为c+1的配置（并成为CM），即使多台机器同时尝试从配置更改带有标识符c的配置。
4. Remap regions。然后，新的CM重新分配先前映射到故障机器的区域，以将副本数量恢复到f+1。它试图在容量和故障独立性约束下平衡负载并满足应用程序指定的位置提示。对于失败的主机器，它总是将生存的备份提升为新的主备份，以减少恢复时间。如果它检测到丢失了所有复制副本的区域，或者没有空间重新复制区域，则会发出错误信号。
5. Send new configuration。重新映射区域后，CM向配置中的所有计算机发送NEW-CONFIG消息，其中包含配置标识符，其自己的标识符，配置中其他计算机的标识符以及区域到计算机的所有新映射。 如果CM已经改变，NEW-CONFIG也会重置租约协议：它充当从新CM到每台机器的租赁请求。 如果CM未更改，则在重新配置期间继续进行租赁交换以快速检测其他故障。
6. Apply new configuration。当计算机收到配置标识符大于其自身的NEW-CONFIG时，它会更新其当前配置标识符及其区域映射的缓存副本，并分配空间以保存分配给它的任何新区域副本。 从这一点来看，它不会向不在配置中的计算机发出新请求，并拒绝读取响应并从这些计算机写入ack。 它还会开始阻止来自外部客户端的请求。 机器使用NEW-CONFIG-ACK消息回复CM。 如果CM已经改变，则这两者都向CM授予租约并请求租赁。
7. Commit new configuration。一旦CM从配置中的所有计算机接收到NEW-CONFIG-ACK消息，它就会等待确保先前配置中授予的不再在配置中的计算机的任何租约都已过期。 然后，CM向所有配置成员发送NEW-CONFIG-COMMIT，这些配置成员也充当租约。 现在，所有成员都会解锁以前阻止的外部客户端请求并启动事务恢复。

### 5.3 Transaction state recovery 

FaRM使用分布在由事务修改的对象副本中的日志在配置更改后恢复事务状态。这包括恢复事务修改对象的副本和协调器的状态，以决定事务的结果。图6显示了一个事务恢复时间表示例。FaRM通过在集群中的线程和机器之间分配工作来实现快速恢复。并行完成所有消息日志的排出（步骤2）。步骤1和步骤3-5是对所有区域并行执行的。步骤6-7是对所有并行恢复事务执行的。

1. Block access to recovering regions。当区域的主备份失败时，在重新配置期间，其中一个备份将升级为新的主备份。在更新区域的所有事务都反映在新的主区域中之前，我们不能允许访问该区域。我们通过阻止对该区域的本地指针和RDMA引用的请求来实现这一点，直到步骤4，当为更新该区域的所有恢复事务获取了所有写锁时。

2.  Drain logs。单边RDMA写入也会影响事务恢复。跨配置一致性的一般方法是拒绝来自旧配置的消息。FaRM无法使用此方法，因为NIC确认写入事务日志的COMMIT-BACKUP和COMMIT-PRIMARY，而不管它们是在哪个配置中发出的。由于协调器在向应用程序公开更新和报告成功之前只等待这些确认，因此机器在处理之前的配置时不能总是拒绝这些记录。我们通过Drain logs来解决这个问题，以确保在恢复过程中处理所有相关的记录：所有机器在收到NEW-CONFIG-COMMIT消息时处理其日志中的所有记录。完成后，它们将配置标识符记录在变量LastDrained中。

   FaRM事务具有在提交开始时分配的唯一标识符<c, m, t, l>，其对提交开始的配置c，协调器的机器标识符m，协调器的线程标识符t和线程局部唯一标识符l进行编码。 配置标识符小于或等于LastDrained的事务的日志记录将被拒绝

3. Find recovering transactions。恢复事务是其提交阶段跨越配置更改的事务，并且由于重新配置，已写入对象的某些副本，某些读取对象的主要副本或协调器已更改。 在日志耗尽期间，检查每个日志中的每个日志记录中的事务标识符和更新的区域标识符列表以确定恢复事务的集合。 只有恢复事务才能在初选和备份中进行事务恢复，协调器仅拒绝恢复事务的硬件响应。

   所有机器必须就特定交易是否为恢复交易达成一致。 我们通过在重新配置阶段捎带一些额外的通信元数据来实现这一点。 CM读取每台机器上的LastDrained变量作为probe读取的一部分。 对于自LastDrained以来其映射已更改的每个区域r，CM将NEW-CONFIG消息中的两个配置标识符发送到该机器。 这些是LastPrimaryChange[r]，它是r的主备份更改时的最后一个配置标识符，以及LastReplicaChange [r]，它是r的任何副本更改时的最后一个配置标识符。 在配置c-1中开始提交的事务正在配置c中恢复，除非：对于包含由事务LastReplicaChange [r] < c修改的对象的所有区域r，对于包含由事务LastLrimaryChange [r‘] < c事务读取的对象的所有区域r‘，协调器尚未从配置c中删除。

   恢复事务的记录可以分布在不同主备份的日志上，并由事务更新备份。区域的每个备份都向主服务器发送一条需要恢复消息，其中包含配置标识符、区域标识符和更新该区域的恢复事务的标识符。

4. Lock recovery。每个区域的主服务器都会等待，直到本地计算机日志被清空，并且从每个备份接收到需要恢复的消息，以构建影响该区域的完整恢复事务集。然后，它在其线程之间按标识符分割事务，以便每个线程t使用协调器线程标识符t恢复事务的状态。同时，主线程从尚未本地存储的备份中提取任何事务日志记录，然后锁定通过恢复事务修改的任何对象。

   当区域的锁定恢复完成时，该区域处于活动状态，本地和远程协调器可以获取本地指针和RDMA引用，这允许它们与后续恢复步骤并行地读取对象并提交对该区域的更新。

5. Replicate log records。主复制日志记录中的线程通过为任何缺少的事务发送REPLICATE-TX-STATE消息备份。 该消息包含区域标识符，当前配置标识符以及与LOCK记录相同的数据。

6. Vote。恢复事务的协调器根据事务更新的每个区域的投票决定是提交还是中止事务。 这些投票由各地区的主机器发送。 FaRM使用一致性散列来确定事务的协调器，确保所有主要独立地就协调器的身份达成协议以进行恢复事务。 如果正在运行的计算机仍在配置中，协调器不会更改，但是当协调器失败时，协调其恢复事务的责任将分布在群集中的计算机上。

   主机器中的线程将RECOVERY-VOTE消息发送到协调器中的对等线程，以用于修改该区域的每个重新覆盖事务。 如果任何副本看到COMMIT-PRIMARY或COMMIT-RECOVERY，则vote为commit-primary。 否则，如果任何副本看到COMMIT-BACKUP并且没有看到ABORT-RECOVERY，则它会对commit-backup进行投票。 否则，如果任何副本看到LOCK记录而没有ABORT-RECOVERY，则它会投票锁定。 否则，它投票中止。 投票消息包括配置标识符，区域标识符，事务标识符以及由事务修改的区域标识符列表。

   一些主机器可能不会为事务启动投票，因为他们从未收到过事务的日志记录，或者他们已经截断了事务的日志记录。 协调器向尚未在超时期限内投票的主机器（设置为250秒）发送明确的投票请求。 REQUEST-VOTE消息包括配置标识符，区域标识符和事务标识符。 在首次等待该事务的日志复制完成之后，具有事务记录的初始记录的主机器就像之前一样。

   如果事务已被截断，则不具有事务投票的任何日志记录的主机器；如果事务未被截断，则为未知。要确定事务是否已被截断，每个线程都会维护其记录已从其日志中截断的事务的标识符集。 通过在非截断事务标识符上使用下限来保持此集合紧凑。 基于每个协调器的下限更新下限，这些下限绑定在协调器消息上并且在重新配置期间。

7. Decide。如果协调器从任何地区收到提交主机器投票，则决定提交交易。 否则，它等待所有区域投票并提交，如果至少有一个区域投票commit-backup，并且该事务修改的所有其他区域都投票lock，commit-backup或truncated。 否则，它决定中止。 然后它将COMMIT-RECOVERY或ABORT-RECOVERY发送给所有参与者副本。 两个消息都包括配置标识符和事务标识符。 如果在主服务器上接收COMMIT-RECOVERY，则处理COMMIT-PRYARY，如果在备份服务器上接收，则处理COMMIT-BACKUP。 ABORT-RECOVERY的处理方式与ABORT类似。 在协调器从所有主要和备份接收到回应之后，它发送TRUNCATE-RECOVERY消息。

**正确性**。接下来，我们提供一些关于事务恢复的不同步骤如何确保严格可序列化的直觉。 关键的想法是恢复保留了先前已提交或中止的事务的结果。 我们说当主要公开事务修改或协调器通知应用程序提交事务时，提交事务。 当协调器发送中止消息或通知应用程序事务已中止时，事务将中止。 对于尚未确定结果的交易，恢复可能会提交或中止交易，但它确保从其他故障中恢复可以保留结果。

使用正常案例协议（第4节）决定未恢复的事务的结果（步骤3）。 所以我们不会进一步讨论它们。

保证在日志耗尽之前或期间处理和接受已提交的恢复事务的日志记录（步骤2）。 这是正确的，因为主机器仅在处理COMMIT-PRIMARY记录之后才会公开修改。 如果协调器通知了应用程序，它必须在收到NEW-CONFIG之前收到所有COMMIT-BACKUP记录和至少一个COMMIT-PRIMARY记录的硬件确认（因为它在更改配置后忽略了ack）。 因此，由于新配置包括每个区域的至少一个副本，因此至少一个区域的至少一个副本将处理COMMIT-PRIMARY或COMMIT-BACKUP记录，并且每个其他区域的至少一个副本将处理COMMIT-PRIMARY， COMMIT-BACKUP或LOCK记录。

步骤3和4确保由事务修改的区域的主机器看到这些记录（除非它们已被截断）。 他们将这些记录复制到备份中（步骤5），以保证即使存在后续故障，投票也会产生相同的结果。 然后，主机器基于他们看到的记录向协调员发送投票（步骤6）。

决策步骤保证协调器决定提交先前已提交的任何事务。 如果任何副本截断了事务记录，则所有主机器都将对commit-primary，commit-backup或truncated进行投票。 至少有一个主机器发送除截断之外的投票，否则，该交易将不会恢复。 如果没有副本截断事务记录，则至少一个主服务器将对commit-primary或commit-backup进行投票，其他主服务器将对commit-primary，commit-backup或lock进行投票。 同样，如果事务先前已中止，协调器将决定中止，因为在这种情况下，将不会有commit-primary或commit-backup记录，或者所有副本都将收到ABORT-RECOVERY。

阻止对恢复区域的访问（步骤1）和锁定恢复（步骤4）保证在恢复事务已提交或中止之前，没有其他操作可以访问它修改的对象。

**性能**。FaRM使用多种优化来实现快速故障恢复。 识别恢复事务将恢复工作限制为仅受重新配置影响的事务和区域，当大型集群中的单个计算机发生故障时，这可能是总计的一小部分。 我们的结果表明，这可以减少一个数量级的交易数量。 恢复工作本身跨区域，机器和线程并行化。 锁定恢复后立即使区域可用可以提高前台性能，因为访问这些区域的新事务不会长时间阻塞。 具体而言，他们无需等待这些区域的新副本更新，这需要通过网络大量移动数据。

### 5.4 Recovering data 

FaRM必须在区域的新备份中恢复（重新复制）数据，以确保它可以容忍将来的f副本故障。 恢复正常情况操作不需要数据恢复，因此我们将其延迟，直到所有区域都变为活动状态，以最大限度地减少对延迟关键锁定恢复的影响。 当所有主要处于活动状态的区域变为活动状态时，每台计算机都会向CM发送REGIONS-ACTIVE消息。 在收到所有REGIONS-ACTIVE消息后，CM向配置中的所有机器发送消息ALL-REGIONS-ACTIVE。 此时，FaRM开始与前台操作并行的新备份数据恢复。

区域的新备份最初具有新分配和归零的本地区域副本。 它跨越工作线程划分区域，并行恢复它。 每个线程发出单侧RDMA操作以一次从主机器读取块。 我们目前使用8 KB块，这块块足够大，可以有效地使用网络，同时它但足够小，不会影响正常的操作。 为了减少对前台性能的影响，通过将下一个读取安排在上一次读取开始后的一个间隔内的随机点（设置为4ms）来调整恢复速度。

在复制到备份之前，必须检查每个恢复的对象。 如果对象的版本大于本地版本，则备份会使用compare-and-swap锁定本地版本，更新对象状态并解锁。 否则，对象已经或正在由创建大于或等于恢复的版本的事务更新，并且未应用恢复的状态。

### 5.5 Recovering allocator state 

FaRM分配器将区域拆分为块（1 MB），这些块用作分配小对象的板（slab）。 它保留两个元数据：块头，包含对象大小，以及无板（slab free）列表。 分配新块时，块头将复制到备份。 这可确保它们在发生故障后可用于新的主数据库。 由于块头用于数据恢复，因此新主机器在收到NEW-CONFIG-COMMIT后立即将它们发送到所有备份。 这可以避免在复制块头时旧主机器发生故障时出现任何不一致。

无板列表只保留在主列表中，以减少对象分配的开销。每个对象的头中都有一个位，由分配设置，并在事务执行期间由空闲对象清除。在事务提交期间复制对对象状态的更改，如第4节所述。失败后，通过扫描区域中的对象，可以在新的主服务器上恢复空闲列表，该区域在计算机上的所有线程之间并行。为了最小化对事务锁恢复的影响，在接收到所有区域活动后开始分配恢复，并通过每100μs扫描100个对象来降低对前台工作的影响。对象释放将排队，直到恢复板的空闲列表。
